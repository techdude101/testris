/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/js/game.js":
/*!************************!*\
  !*** ./src/js/game.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Game\": () => (/* binding */ Game)\n/* harmony export */ });\n/* harmony import */ var _tetromino__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tetromino */ \"./src/js/tetromino.js\");\n\n\nclass Game {\n    constructor(gameCanvas, score = 0, lives = 1, speed = 1) {\n        this.keys = {\n            left: false,\n            right: false,\n            rotate: false,\n        };\n\n        this.mouseDown = false;\n        \n        this.gameBoard = [];\n\n        this.squareSize = 10;\n\n        this.level = 1;\n        this.score = score;\n        this.lives = lives;\n        this.speed = speed;\n        this.delta = 1 / speed;\n        this.gameCanvas = gameCanvas;\n        this.state = 'New Game';\n        this.dead = false;\n        this.gameFont = \"monospace\";\n\n        this.tickCount = 0;\n\n        this.newGame();\n\n        this.update = this.update.bind(this);\n\n        // Event listeners\n        this.keyDownHandlerBind = this.keyDownHandlerBind.bind(this);\n        this.keyUpHandlerBind = this.keyUpHandlerBind.bind(this);\n        this.mouseHandlerBind = this.mouseHandlerBind.bind(this);\n        this.touchHandlerBind = this.touchHandlerBind.bind(this);\n        this.controlsHandlerBind = this.controlsHandlerBind.bind(this);\n\n        document.addEventListener('keydown', this.keyDownHandlerBind);\n        document.addEventListener('keyup', this.keyUpHandlerBind);\n        document.addEventListener('mousedown', this.mouseHandlerBind);\n        document.addEventListener('mouseup', this.mouseHandlerBind);\n        \n        const buttons = document.querySelectorAll('.controls-container button');\n        buttons.forEach(button => {\n            button.addEventListener('click', this.controlsHandlerBind);\n            button.addEventListener('touchend', this.touchHandlerBind);\n            button.addEventListener('touchstart', this.touchHandlerBind);\n            button.addEventListener('touchcancel', this.touchHandlerBind);\n            button.addEventListener('touchmove', this.touchHandlerBind);\n        });\n    }\n\n    newGame() {\n        this.keys = {\n            left: false,\n            right: false,\n            rotate: false,\n        };\n\n        this.mouseDown = false;\n\n        this.gameBoard = [];\n        for (let row = 0; row < (this.gameCanvas.height / this.squareSize); row++) {\n            let cells = [];\n            for (let cell = 0; cell < (this.gameCanvas.width / this.squareSize); cell++) {\n                cells.push('0');\n            }\n            this.gameBoard.push(cells);\n        }\n\n        // For testing\n        for (let i = 0; i < 28; i++) {\n            this.gameBoard[39][i] = '1';\n        }\n\n        for (let i = 0; i < 28; i++) {\n            this.gameBoard[38][i] = '1';\n        }\n\n        if (this.state === 'Won') {\n            this.dead = true;\n        }\n        if (this.dead) {\n            this.score = 0;\n            this.level = 1;\n            this.dead = false;\n            this.lives = 1;\n        }\n\n        this.tickCount = 0;\n\n        // Create game objects\n        this.tetromino = new _tetromino__WEBPACK_IMPORTED_MODULE_0__.default(this.gameCanvas, this.squareSize);\n\n        this.drawNewGame(this.gameCanvas.width / 2, this.gameCanvas.height / 2, 40);\n    }\n\n    controlsHandlerBind(e) {\n        // if (e.target.id === 'control-left') {\n        //     this.tetromino.moveLeft();\n        // } else if (e.target.id === 'control-right') {\n        //     this.tetromino.moveRight();\n        // } else if (e.target.id === 'control-rotate') {\n        //     this.rotate();\n        // }\n    }\n    \n    touchHandlerBind(e) {\n        e.preventDefault();\n        if (e.type === \"touchstart\") {\n            if (e.target.id === 'control-left') {\n                this.keys['left'] = true;\n            } else if (e.target.id === 'control-right') {\n                this.keys['right'] = true;\n            } else if (e.target.id === 'control-rotate') {\n                this.keys['rotate'] = true;\n            }\n        } else if (e.type === \"touchend\") {\n            if (e.target.id === 'control-left') {\n                // this.keys['left'] = false;\n            } else if (e.target.id === 'control-right') {\n                // this.keys['right'] = false;\n            } else if (e.target.id === 'control-rotate') {\n                // this.keys['rotate'] = false;\n            }\n        }\n    }\n\n    mouseHandlerBind(e) {\n        if (e.buttons > 0) {\n            this.mouseDown = true;\n        } else {\n            this.mouseDown = false;\n        }\n    }\n\n    keyDownHandlerBind(e) {\n        if (e.key === 'a') { this.keys['left'] = true; }\n        if (e.key === 'ArrowLeft') {\n            this.keys['left'] = true;\n        }\n\n        if (e.key === 'd') { this.keys['right'] = true; }\n        if (e.key === 'ArrowRight') {\n            this.keys['right'] = true;\n        }\n\n        if (e.key === 's') { this.keys['rotate'] = true; }\n    }\n\n    keyUpHandlerBind(e) {\n        // if (e.key === 'a') { this.keys['left'] = false; }\n        // if (e.key === 'ArrowLeft') {\n        //     this.keys['left'] = false;\n        // }\n\n        // if (e.key === 'd') { this.keys['right'] = false; }\n        // if (e.key === 'ArrowRight') {\n        //     this.keys['right'] = false;\n        // }\n\n        // if (e.key === 's') { this.keys['rotate'] = false; }\n    }\n\n    drawWonScreen(x, y, fontSize) {\n        const context = this.gameCanvas.getContext('2d');\n        context.fillStyle = '#FFF';\n        context.font = `${fontSize}px ${this.gameFont}`;\n        const text = \"You won!\";\n        let textWidth = context.measureText(text).width;\n\n        context.fillText(text, x - (textWidth / 2), y - (fontSize / 2));\n\n        const controlsFontSize = fontSize / 3;\n        context.font = `bold ${controlsFontSize}px ${this.gameFont}`;\n        const controls = \"Press a button to play again\";\n        textWidth = context.measureText(controls).width;\n        context.fillText(controls, x - (textWidth / 2), y + controlsFontSize);\n    }\n\n    drawGameOver(x, y, text, fontSize) {\n        const context = this.gameCanvas.getContext('2d');\n        context.fillStyle = '#FFF';\n        context.font = `${fontSize}px ${this.gameFont}`;\n\n        const textWidth = context.measureText(text).width;\n\n        context.fillText(text, x - (textWidth / 2), y);\n    }\n\n    drawInstructions(x, y, fontSize) {\n        const context = this.gameCanvas.getContext('2d');\n        context.fillStyle = '#FFF';\n        context.font = `${fontSize}px ${this.gameFont}`;\n        const text = `Press a key to continue`;\n        const textWidth = context.measureText(text).width;\n\n        context.fillText(text, x - (textWidth / 2), y + (fontSize / 2));\n    }\n\n    drawLevel(x, y, level, fontSize) {\n        const context = this.gameCanvas.getContext('2d');\n        context.fillStyle = '#FFF';\n        context.font = `${fontSize}px ${this.gameFont}`;\n        const text = `Level: ${level}`;\n        const textWidth = context.measureText(text).width;\n\n        context.fillText(text, x - (textWidth / 2), y);\n    }\n\n    drawNewGame(x, y, fontSize) {\n        const context = this.gameCanvas.getContext('2d');\n        context.fillStyle = '#FFF';\n        context.font = `${fontSize}px ${this.gameFont}`;\n        const text = \"New Game\";\n        let textWidth = context.measureText(text).width;\n\n        context.fillText(text, x - (textWidth / 2), y - (fontSize / 2));\n\n        const controlsFontSize = fontSize / 3;\n        context.font = `bold ${controlsFontSize}px ${this.gameFont}`;\n        const controls = \"Left: A, Right: D, Rotate: S\";\n        textWidth = context.measureText(controls).width;\n        context.fillText(controls, x - (textWidth / 2), y + controlsFontSize);\n    }\n\n    drawSquare(x, y) {\n        const context = this.gameCanvas.getContext('2d');\n        context.beginPath();\n        context.fillStyle = \"green\";\n        context.strokeStyle = \"black\";\n        context.fillRect(x, y, this.squareSize, this.squareSize);\n        context.rect(x, y, this.squareSize, this.squareSize);\n        context.stroke();        \n    }\n\n    draw() {\n        const context = this.gameCanvas.getContext('2d');\n        // Clear the canvas\n        context.fillStyle = '#000';\n        context.fillRect(0, 0, this.gameCanvas.width, this.gameCanvas.height);\n        if (this.state !== 'Playing') {\n            context.globalAlpha = 0.3;\n        } else {\n            context.globalAlpha = 1;\n        }\n        \n        this.tetromino.draw();\n\n        for (let i = 0; i < this.gameBoard.length; i++) {\n            for (let j = 0; j < this.gameBoard[i].length; j++) {\n                if (this.gameBoard[i][j] == '1') {\n                    this.drawSquare(j * this.squareSize, i * this.squareSize);\n                }\n            }\n        }\n\n        context.globalAlpha = 1;\n\n        if (this.state === 'Next Level') {\n            const middleOfCanvas = this.gameCanvas.width / 2;\n            const fontSize = 40;\n            // this.drawLevel(middleOfCanvas, this.gameCanvas.height / 2, this.level, fontSize);\n            this.drawInstructions(middleOfCanvas, this.gameCanvas.height / 2 + (fontSize), (fontSize / 3));\n        } else if (this.state === 'Game Over') {\n            const middleOfCanvas = this.gameCanvas.width / 2;\n            const fontSize = 40;\n            this.drawGameOver(middleOfCanvas, this.gameCanvas.height / 2, \"Game Over\", fontSize);\n            this.drawInstructions(middleOfCanvas, this.gameCanvas.height / 2 + (fontSize), (fontSize / 3));\n        } else if (this.state === 'New Game') {\n            const middleOfCanvas = this.gameCanvas.width / 2;\n            const fontSize = 40;\n            this.drawNewGame(middleOfCanvas, this.gameCanvas.height / 2, fontSize);\n        } else if (this.state === 'Won') {\n            const middleOfCanvas = this.gameCanvas.width / 2;\n            const fontSize = 30;\n            this.drawWonScreen(middleOfCanvas, this.gameCanvas.height / 2, fontSize);\n        }\n    }\n\n    isRowComplete(row) {\n        let expectedCellCount = this.gameCanvas.width / this.squareSize;\n\n        for (let i = 0; i < expectedCellCount; i++) {\n            if (this.gameBoard[row][i] != '1') {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    isGameOver() {\n        return (this.lives < 1);\n    }\n\n    removeRow(row) {\n        for (let i = 0; i < this.gameBoard.length; i++) {\n            this.gameBoard[row - 1][i] = '0';\n        }\n    }\n\n    shiftGameBoardDown(removedRow) {\n        // Start at the last row in the array\n        // Copy previous row into the last row\n        // Decrement the row index and repeat\n        // until row index is 1\n        for (let row = removedRow; row >= 1; row--) {\n            for (let column = 0; column < this.gameBoard[0].length; column++) {\n                this.gameBoard[row][column] = this.gameBoard[row - 1][column];\n            }\n        }\n    }\n\n    update() {\n        // updates every 50ms\n        this.tickCount += 1;\n        const gameScore = document.querySelector('.game-score');\n        const gameLevel = document.querySelector('.game-level');\n\n        gameLevel.style.visibility = \"hidden\";\n\n        if (this.isGameOver() && this.state !== 'Game Over') {\n            this.state = 'Game Over';\n            this.dead = true;\n            this.lives = 0;\n        }\n        \n        // updates every 50ms\n        if (this.state === 'Playing' ) {\n            // Check for collisions\n            let collisionDetected = this.collisionCheck('bottom');\n            if (collisionDetected) {\n                this.tetromino.lock();\n                let filledCells = this.tetromino.getFilledPositions();\n\n                filledCells.forEach(cell => {\n                    let y = (cell.y / this.squareSize);\n                    let x = (cell.x / this.squareSize);\n                    this.gameBoard[y][x] = '1';\n                })\n\n                this.tetromino = new _tetromino__WEBPACK_IMPORTED_MODULE_0__.default(this.gameCanvas, this.squareSize);\n            }\n\n            // Update positions\n            if (this.tickCount > 2) {\n                this.updatePlayerPosition();\n            }\n\n            if (this.tickCount >= 5) {\n                this.tickCount = 0;\n                this.moveTetrominoDown();\n            }\n\n            // For each complete row remove the row\n            // Shift all cells above the completed row down\n            let rowsComplete = [];\n            for (let row = 0; row < this.gameCanvas.height / this.squareSize; row++) {\n                if (this.isRowComplete(row)) {\n                    rowsComplete.push(row);\n                    this.shiftGameBoardDown(row);\n                    this.score += 1;\n                }\n            }\n\n            if (rowsComplete.length > 0) {\n                this.tetromino = new _tetromino__WEBPACK_IMPORTED_MODULE_0__.default(this.gameCanvas, this.squareSize);\n            }\n        }\n\n        // Update score\n        gameScore.innerText = `Score: ${this.score}`;\n\n        if ((this.state !== 'Playing') && ((this.mouseDown) \n            || this.keys['rotate']\n            || this.keys['left']\n            || this.keys['right'])) {\n            if (this.state !== 'New Game') { this.newGame(); }\n            this.state = 'Playing';\n        }\n\n        this.draw();\n    }\n\n    moveTetrominoDown() {\n        if (this.collisionCheck('bottom') === false) {\n            this.tetromino.moveDown();\n        }\n\n        if (this.collisionCheck('top')) {\n            this.tetromino.lock();\n            this.lives = 0;\n        }\n    }\n\n    updatePlayerPosition() {\n        if (this.keys['left']) {\n            this.keys['left'] = false;\n            if (this.collisionCheck('left') === false) { this.tetromino.moveLeft(); }\n        } else if (this.keys['right']) {\n            if (this.collisionCheck('right') === false) { this.tetromino.moveRight(); }\n            this.keys['right'] = false;\n        }\n        else if (this.keys['rotate']) {\n            this.keys['rotate'] = false;\n            this.tetromino.rotate();\n        }\n    }\n\n    collisionCheck(type) {\n        let collision = false;\n\n        // Collision between Tetromino and filled cells\n        let tetrominoCells = this.tetromino.getFilledPositions();\n        tetrominoCells.forEach(cell => {\n            if (type === 'top') {\n                // TODO: Prevent code duplication\n                if ((cell.y / this.squareSize) + 1 <= this.gameBoard.length - 1) {\n                    if (this.gameBoard[(cell.y / this.squareSize) + 1][(cell.x / this.squareSize)] == '1'\n                    && (cell.y / this.squareSize) <= 2) {\n                        collision = true;\n                    }\n                }\n            }\n            else if (type === 'bottom') {\n                // Bottom of screen\n                // if (this.tetromino.getBottom() >= (this.gameCanvas.height - this.squareSize)) {\n                //     collision = true;\n                // }\n                if ((cell.y / this.squareSize) + 1 > this.gameBoard.length - 1) {\n                    collision = true;\n                }\n\n                // Directly below\n                if ((cell.y / this.squareSize) + 1 <= this.gameBoard.length - 1) {\n                    if (this.gameBoard[(cell.y / this.squareSize) + 1][(cell.x / this.squareSize)] == '1') {\n                        collision = true;\n                    }\n                }\n            } else if (type === 'left') {\n                // Left\n                // Prevent array index exception\n                if ((cell.x / this.squareSize) - 1 >= 0) {\n                    if (this.gameBoard[cell.y / this.squareSize][(cell.x / this.squareSize) - 1] == '1') {\n                        collision = true;\n                    }\n                }\n            } else if (type === 'right') {\n                // Right\n                // Prevent array index exception\n                if ((cell.x / this.squareSize) + 1 <= this.gameBoard[0].length - 1) {\n                    if (this.gameBoard[cell.y / this.squareSize][(cell.x / this.squareSize) + 1] == '1') {\n                        collision = true;\n                    }\n                }\n            }\n        });      \n        \n        return collision;\n    }\n}\n\n//# sourceURL=webpack://testris/./src/js/game.js?");

/***/ }),

/***/ "./src/js/index.js":
/*!*************************!*\
  !*** ./src/js/index.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _game__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./game */ \"./src/js/game.js\");\n// require('../css/styles.css');\n\n\n\n// Elements\nconst gameContainer = document.querySelector('.game-container');\nconst gameScore = document.querySelector('.game-score');\nconst gameLives = document.querySelector('.game-lives');\nconst gameElement = document.querySelector('.game');\nconst gameCanvas = document.querySelector('.game-canvas');\nconst buttonRotateContainer = document.querySelector('.button-rotate-container');\nconst controlsContainer = document.querySelector('.controls-container');\n\nconst PIXEL_RATIO = (function () {\n    let ctx = document.createElement(\"canvas\").getContext(\"2d\"),\n        dpr = window.devicePixelRatio || 1,\n        bsr = ctx.webkitBackingStorePixelRatio ||\n            ctx.mozBackingStorePixelRatio ||\n            ctx.msBackingStorePixelRatio ||\n            ctx.oBackingStorePixelRatio ||\n            ctx.backingStorePixelRatio || 1;\n\n    return dpr / bsr;\n})();\n\n\nconst convertHiDPICanvas = function (canvas, w, h, ratio) {\n    if (!ratio) { ratio = PIXEL_RATIO; }\n    canvas.width = w * ratio;\n    canvas.height = h * ratio;\n    canvas.style.width = w + \"px\";\n    canvas.style.height = h + \"px\";\n    canvas.getContext(\"2d\").setTransform(ratio, 0, 0, ratio, 0, 0);\n    return canvas;\n}\n\n//Create canvas with the device resolution.\n// const canvas = convertHiDPICanvas(gameCanvas, window.innerWidth * 0.5, window.innerHeight * 0.5);\n\nconst game = new _game__WEBPACK_IMPORTED_MODULE_0__.Game(gameCanvas);\n\ncontrolsContainer.style.visibility = \"hidden\";\ncontrolsContainer.style.display = \"none\";\n\n// Detect touch event and display controls if touch is detected\nwindow.addEventListener('touchstart', () => {\n    controlsContainer.style.visibility = \"visible\";\n    controlsContainer.style.display = \"flex\";\n}, false);\n\nsetTimeout(function() {\n    game.draw();\n}, 1000);\n\n// Game loop\nsetInterval(game.update, 50);\n\n//# sourceURL=webpack://testris/./src/js/index.js?");

/***/ }),

/***/ "./src/js/tetromino.js":
/*!*****************************!*\
  !*** ./src/js/tetromino.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Tetromino)\n/* harmony export */ });\nclass Tetromino {\n  constructor(canvasElement, squareSize) {\n    this.gameCanvas = canvasElement;\n    this.squareSize = squareSize;\n\n    this.x = this.gameCanvas.width / 2;\n    this.y = this.squareSize;\n\n    this.top = this.y;\n    this.left = this.x;\n    this.bottom = this.y + this.squareSize;\n    this.right = this.x + this.squareSize;\n\n    this.rotation = 0;\n\n    this.speed = 5;\n    this.locked = false;\n\n    // Generate random tetromino type\n    let typeIndex = parseInt((Math.random() * 10) % 5);\n    this.types = { 0: \"straight\", 1: \"skew\", 2: \"T\", 3: \"L\", 4: \"square\" };\n\n    // For testing complete row\n    // typeIndex = 4;\n\n    this.initializeTetromino(this.types[typeIndex]);\n  }\n\n  initializeTetromino(type) {\n    let tetromino = `\n        0000\n        0000\n        0000\n        0000`;\n\n    if (type == \"straight\") {\n      tetromino = \"1111\";\n      tetromino += \"0000\";\n      tetromino += \"0000\";\n      tetromino += \"0000\";\n      tetromino += \"0000\";\n      tetromino += \"0000\";\n    } else if (type == \"square\") {\n      tetromino = \"0110\";\n      tetromino += \"0110\";\n      tetromino += \"0000\";\n      tetromino += \"0000\";\n    } else if (type == \"L\") {\n      tetromino = \"1000\";\n      tetromino += \"1000\";\n      tetromino += \"1100\";\n      tetromino += \"0000\";\n    } else if (type == \"T\") {\n      tetromino = \"1110\";\n      tetromino += \"0100\";\n      tetromino += \"0000\";\n      tetromino += \"0000\";\n    } else if (type == \"skew\") {\n      tetromino = \"0011\";\n      tetromino += \"0110\";\n      tetromino += \"0000\";\n      tetromino += \"0000\";\n    }\n\n    this.tetromino = tetromino;\n    this.type = type;\n  }\n\n  getBottom() {\n    if (this.type == \"straight\") {\n      return this.y + this.squareSize;\n    } else if (\n      this.type == \"skew\" ||\n      this.type == \"square\" ||\n      this.type == \"T\"\n    ) {\n      return this.y + this.squareSize * 2;\n    } else if (this.type == \"L\") {\n      return this.y + this.squareSize * 4;\n    }\n  }\n\n  getFilledWidth() {\n    if (this.type == \"square\") {\n      return this.squareSize * 2;\n    }\n    switch (this.rotation) {\n      case 0:\n      // Fall through\n      case 180:\n        if (this.type == \"straight\") {\n          return this.squareSize * 4;\n        } else if (this.type == \"L\") {\n          return this.squareSize * 2;\n        } else if (this.type == \"T\" || this.type == \"skew\") {\n          return this.squareSize * 3;\n        }\n        break;\n      case 90:\n      // Fall through\n      case 270:\n        if (this.type == \"straight\") {\n          return this.squareSize * 1;\n        } else if (this.type == \"skew\" || this.type == \"T\") {\n          return this.squareSize * 2;\n        } else if (this.type == \"L\") {\n          return this.squareSize * 3;\n        }\n        break;\n\n      default:\n        break;\n    }\n  }\n\n  lock() {\n    this.locked = true;\n  }\n\n  rotate() {\n    // TODO: Do this in a better way\n    let tetromino = \"\";\n    let type = this.type;\n    console.log(\"Rotate\");\n    if (this.locked === false) {\n      this.rotation += 90;\n      if (this.rotation > 270) {\n        this.rotation = 0;\n      }\n    }\n    switch (this.rotation) {\n        case 0: {\n            this.initializeTetromino(type);\n            tetromino = this.tetromino;\n            break;\n        }\n        case 90:\n        if (type == \"straight\") {\n          tetromino = \"0001\";\n          tetromino += \"0001\";\n          tetromino += \"0001\";\n          tetromino += \"0001\";\n        } else if (type == \"square\") {\n          tetromino = \"0110\";\n          tetromino += \"0110\";\n          tetromino += \"0000\";\n          tetromino += \"0000\";\n        } else if (type == \"L\") {\n          tetromino = \"1110\";\n          tetromino += \"1000\";\n          tetromino += \"0000\";\n          tetromino += \"0000\";\n        } else if (type == \"T\") {\n          tetromino = \"0001\";\n          tetromino += \"0011\";\n          tetromino += \"0001\";\n          tetromino += \"0000\";\n        } else if (type == \"skew\") {\n          tetromino = \"0000\";\n          tetromino += \"0010\";\n          tetromino += \"0011\";\n          tetromino += \"0001\";\n        }\n        break;\n      case 180:\n        if (type == \"straight\") {\n          tetromino = \"0000\";\n          tetromino += \"0000\";\n          tetromino += \"0000\";\n          tetromino += \"1111\";\n        } else if (type == \"square\") {\n          tetromino = \"0110\";\n          tetromino += \"0110\";\n          tetromino += \"0000\";\n          tetromino += \"0000\";\n        } else if (type == \"L\") {\n          tetromino = \"0011\";\n          tetromino += \"0001\";\n          tetromino += \"0001\";\n          tetromino += \"0000\";\n        } else if (type == \"T\") {\n          tetromino = \"0000\";\n          tetromino += \"0000\";\n          tetromino += \"0010\";\n          tetromino += \"0111\";\n        } else if (type == \"skew\") {\n          tetromino = \"0000\";\n          tetromino += \"0000\";\n          tetromino += \"0110\";\n          tetromino += \"1100\";\n        }\n        break;\n      case 270:\n        if (type == \"straight\") {\n          tetromino = \"1000\";\n          tetromino += \"1000\";\n          tetromino += \"1000\";\n          tetromino += \"1000\";\n        } else if (type == \"square\") {\n          tetromino = \"0110\";\n          tetromino += \"0110\";\n          tetromino += \"0000\";\n          tetromino += \"0000\";\n        } else if (type == \"L\") {\n          tetromino = \"0000\";\n          tetromino += \"0000\";\n          tetromino += \"0100\";\n          tetromino += \"0111\";\n        } else if (type == \"T\") {\n          tetromino = \"1000\";\n          tetromino += \"1100\";\n          tetromino += \"1000\";\n          tetromino += \"0000\";\n        } else if (type == \"skew\") {\n          tetromino = \"1000\";\n          tetromino += \"1100\";\n          tetromino += \"0100\";\n          tetromino += \"0000\";\n        }\n        break;\n    }\n    this.tetromino = tetromino;\n  }\n\n  getFilledPositions() {\n    let positions = [];\n\n    let x = this.x;\n    let y = this.y;\n\n    for (let i = 0; i < this.tetromino.length; i++) {\n      if (i % 4 == 0) {\n        y += this.squareSize;\n      }\n\n      if (this.tetromino[i] == \"1\") {\n        positions.push({ x: x, y: y });\n      }\n\n      x += this.squareSize;\n\n      if (x >= this.x + 4 * this.squareSize) {\n        x = this.x;\n      }\n    }\n    return positions;\n  }\n\n  drawSquare(x, y) {\n    const context = this.gameCanvas.getContext(\"2d\");\n    context.beginPath();\n    context.fillStyle = \"green\";\n    context.strokeStyle = \"black\";\n    context.fillRect(x, y, this.squareSize, this.squareSize);\n    context.rect(x, y, this.squareSize, this.squareSize);\n    context.stroke();\n  }\n\n  draw() {\n    let x = this.x;\n    let y = this.y;\n\n    for (let i = 0; i < this.tetromino.length; i++) {\n      if (i % 4 == 0) {\n        y += this.squareSize;\n      }\n\n      if (this.tetromino[i] == \"1\") {\n        this.drawSquare(x, y);\n      }\n\n      x += this.squareSize;\n\n      if (x >= this.x + 4 * this.squareSize) {\n        x = this.x;\n      }\n    }\n  }\n\n  moveLeft() {\n    if (this.locked === false) {\n      let x = 0;\n      let y = 0;\n      let canMove = true;\n      for (let i = 0; i < this.tetromino.length; i++) {\n        if (i % 4 == 0) {\n          y += this.squareSize;\n        }\n\n        if (this.tetromino[i] == \"1\") {\n          // If x position of '1' is > 0\n          // OK to move piece left\n          x = i % 4;\n          x *= this.squareSize;\n          canMove &= (this.x + x) > 0;\n        }\n      }\n\n      if (canMove) {\n        this.x -= this.squareSize;\n      }\n    }\n  }\n\n  moveRight() {\n    if (this.locked === false) {\n      let x = 0;\n      let y = 0;\n      let canMove = true;\n      for (let i = 0; i < this.tetromino.length; i++) {\n        if (i % 4 == 0) {\n          y += this.squareSize;\n        }\n\n        if (this.tetromino[i] == \"1\") {\n          // If x position of '1' is > 0\n          // OK to move piece left\n          x = i % 4;\n          x *= this.squareSize;\n          canMove &= (this.x + x) < (this.gameCanvas.width - this.squareSize);\n        }\n      }\n\n      if (canMove) {\n        this.x += this.squareSize;\n      }\n    }\n  }\n\n  moveDown() {\n    if (this.locked === false) {\n      this.y += this.squareSize;\n      if (this.y + this.squareSize > this.gameCanvas.height) {\n        this.y = this.gameCanvas.width - this.squareSize;\n      }\n    }\n  }\n}\n\n\n//# sourceURL=webpack://testris/./src/js/tetromino.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/js/index.js");
/******/ 	
/******/ })()
;